<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>The Tuan Muda Series â€” 3x3</title>
  <style>
    :root{
      --bg1:#0b1220;
      --bg2:#111a2e;
      --card: rgba(255,255,255,0.06);
      --card2: rgba(255,255,255,0.08);
      --stroke: rgba(255,255,255,0.12);
      --text:#eaf0ff;
      --muted: rgba(234,240,255,0.72);
      --accent1:#7c3aed;
      --accent2:#22d3ee;
      --shadow: 0 20px 60px rgba(0,0,0,.35);
      --radius: 18px;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(124,58,237,.35), transparent 60%),
        radial-gradient(900px 600px at 90% 20%, rgba(34,211,238,.25), transparent 55%),
        radial-gradient(900px 600px at 50% 90%, rgba(59,130,246,.15), transparent 55%),
        linear-gradient(160deg, var(--bg1), var(--bg2));
      min-height: 100vh;
    }

    .wrap { max-width: 1060px; margin: 0 auto; padding: 26px 18px 48px; }

    .brand {
      display:flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 18px;
    }

    .brand-badge{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding: 10px 14px;
      border-radius: 999px;
      width: fit-content;
      background: linear-gradient(90deg, rgba(124,58,237,.25), rgba(34,211,238,.18));
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .spark {
      width: 12px; height: 12px; border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,0) 55%),
                  linear-gradient(135deg, var(--accent1), var(--accent2));
      box-shadow: 0 0 18px rgba(34,211,238,.25), 0 0 18px rgba(124,58,237,.2);
    }

    .brand-title{
      font-weight: 900;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      font-size: clamp(30px, 4vw, 46px);
      line-height: 1.05;
      margin: 0;
      background: linear-gradient(90deg, #ffffff, rgba(255,255,255,.6), #ffffff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 12px 40px rgba(0,0,0,.3);
    }

    .sub {
      color: var(--muted);
      margin: 0;
      font-size: 14px;
      max-width: 820px;
    }

    .topbar{
      display:flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin: 18px 0 18px;
      flex-wrap: wrap;
    }

    .pill{
      padding: 10px 12px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.05);
      border-radius: 999px;
      box-shadow: 0 10px 30px rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
      color: var(--muted);
      font-size: 13px;
    }

    .actions { display:flex; gap: 10px; flex-wrap: wrap; }

    button{
      appearance: none;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      color: var(--text);
      padding: 10px 14px;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 12px 26px rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-weight: 700;
    }
    button:hover{
      transform: translateY(-1px);
      border-color: rgba(255,255,255,.22);
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
    }
    button:active{ transform: translateY(0px) scale(.99); }

    .section{
      display: grid;
      grid-template-columns: 1.15fr .85fr;
      gap: 18px;
      align-items: start;
    }
    @media (max-width: 920px){
      .section{ grid-template-columns: 1fr; }
    }

    .panel{
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, var(--card), rgba(255,255,255,0.03));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .panel-head{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.09);
      display:flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      background: linear-gradient(90deg, rgba(124,58,237,.10), rgba(34,211,238,.06));
    }
    .panel-head h2{
      margin: 0;
      font-size: 16px;
      letter-spacing: .4px;
    }
    .panel-head .hint{
      color: var(--muted);
      font-size: 12px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      padding: 14px;
    }

    .game{
      border: 1px solid rgba(255,255,255,0.10);
      background: linear-gradient(180deg, var(--card2), rgba(255,255,255,0.03));
      border-radius: 16px;
      padding: 12px;
      box-shadow: 0 12px 30px rgba(0,0,0,.18);
    }

    .game-top{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .gtitle{
      font-weight: 800;
      letter-spacing: .5px;
      font-size: 14px;
      opacity: .95;
    }

    .inputs{
      display:flex;
      gap: 8px;
      align-items:center;
    }

    input[type="number"], input[type="text"], select{
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(10,14,25,0.55);
      color: var(--text);
      outline: none;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.1);
      transition: border-color .12s ease, transform .12s ease;
    }
    input[type="number"]{ width: 92px; }
    input[type="text"]{ width: 100%; }
    select{ width: 120px; }

    input:focus, select:focus{
      border-color: rgba(34,211,238,.55);
      transform: translateY(-1px);
    }

    .teams{
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 12px;
      align-items:center;
      margin-top: 2px;
    }

    .team{
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.10);
      font-weight: 650;
      font-size: 13px;
      line-height: 1.3;
      transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease;
    }

    .vs{
      color: rgba(234,240,255,.7);
      font-weight: 800;
      letter-spacing: 1px;
      font-size: 12px;
      text-transform: uppercase;
    }

    .standings-wrap{
      padding: 10px 14px 14px;
    }

    table{
      width: 100%;
      border-collapse: collapse;
      overflow: hidden;
      border-radius: 14px;
    }

    thead th{
      text-align: left;
      padding: 10px 10px;
      font-size: 12px;
      letter-spacing: .35px;
      text-transform: uppercase;
      color: rgba(234,240,255,.72);
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }

    tbody td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      font-size: 14px;
    }

    tbody tr:hover{ background: rgba(255,255,255,0.04); }

    .rank{ font-weight: 900; width: 54px; }
    .name{ font-weight: 750; }

    .chip{
      display:inline-flex;
      align-items:center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      font-size: 12px;
      color: rgba(234,240,255,.85);
    }

    .note{ color: var(--muted); font-size: 13px; padding: 0 14px 14px; }
    .footer{ margin-top: 18px; color: rgba(234,240,255,.55); font-size: 12px; text-align: center; }

    /* Winner highlight */
    .team.winner {
      border: 1px solid rgba(34,211,238,.6);
      background: linear-gradient(180deg, rgba(34,211,238,.18), rgba(34,211,238,.08));
      box-shadow: 0 0 18px rgba(34,211,238,.35);
      transform: translateY(-2px);
    }

    /* Medal styling */
    .medal { font-size: 16px; margin-right: 6px; }

    /* Setup layout */
    .setup-row{
      display:grid;
      grid-template-columns: 220px 1fr;
      gap: 12px;
      padding: 14px;
      align-items:center;
    }
    @media (max-width: 720px){
      .setup-row{ grid-template-columns: 1fr; }
      select{ width: 100%; }
    }
    .names-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      padding: 0 14px 14px;
    }
    @media (max-width: 720px){
      .names-grid{ grid-template-columns: 1fr; }
    }

    .hidden{ display:none !important; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="brand">
      <div class="brand-badge">
        <span class="spark"></span>
        <span style="font-weight:800; letter-spacing:.4px;">Specially made by TUAN MUDA NIEL</span>
      </div>
      <h1 class="brand-title">The Tuan Muda Series</h1>
      <p class="sub">3x3 Basketball Generator â†’ Track scores â†’ Auto standings. </p>
    </div>

    <!-- SETUP SCREEN -->
    <div id="setupScreen" class="panel">
      <div class="panel-head">
        <h2>Setup</h2>
        <div class="hint">Choose 6â€“12 players</div>
      </div>

      <div class="setup-row">
        <div class="pill">Number of players</div>
        <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
          <select id="playerCount">
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
            <option value="10" selected>10</option>
            <option value="11">11</option>
            <option value="12">12</option>
          </select>

          <span class="pill" style="margin:0;">Games generated</span>
          <select id="gamesCount">
            <option value="4">4</option>
            <option value="6">6</option>
            <option value="8">8</option>
            <option value="9" selected>9</option>
            <option value="12">12</option>
          </select>

          <button id="btnGenerate">Generate Matches</button>
        </div>
      </div>

      <div class="note"></div>
      <div id="namesGrid" class="names-grid"></div>

      <div class="note">
        Tip: If you want your exact old fixed schedule, keep using the old gamesData. This setup mode generates a fresh random schedule each time.
      </div>
    </div>

    <!-- LEAGUE SCREEN -->
    <div id="leagueScreen" class="hidden">
      <div class="topbar">
        <div class="pill">Note: A game only counts once <b>both</b> scores are entered.</div>
        <div class="actions">
          <button id="btnBack">Back to Setup</button>
          <button id="btnReset">Reset Scores</button>
          <button id="btnRegenerate">Regenerate Matches</button>
          <button id="btnClearLeague">Clear League</button>
        </div>
      </div>

      <div class="section">
        <div class="panel">
          <div class="panel-head">
            <h2>Games</h2>
            <div class="hint">Winner glows automatically</div>
          </div>
          <div id="games" class="grid"></div>
          <div class="note">Draw = no glow.</div>
        </div>

        <div class="panel">
          <div class="panel-head">
            <h2>Standings</h2>
            <div class="hint">
              <span class="chip">Pts</span>
              <span class="chip">Diff</span>
            </div>
          </div>
          <div class="standings-wrap">
            <table>
              <thead>
                <tr>
                  <th style="width:60px;">Rank</th>
                  <th>Player</th>
                  <th style="width:52px;">W</th>
                  <th style="width:52px;">D</th>
                  <th style="width:52px;">L</th>
                  <th style="width:70px;">Pts</th>
                  <th style="width:70px;">Diff</th>
                </tr>
              </thead>
              <tbody id="standingsBody"></tbody>
            </table>
          </div>
          <div class="note"></div>
        </div>
      </div>

      <div class="footer">Â© TUAN MUDA NIEL</div>
    </div>
  </div>

<script>
  // ---------- Storage ----------
  const STORE = {
    games: "tmn_gamesData_v2",
    roster: "tmn_roster_v2",
    meta: "tmn_meta_v2",
  };
  const scoreKey = (gameId, side) => `g${gameId}_${side}`;

  // Default premium roster (edit on setup)
  const DEFAULT_NAMES = [
    "Harvick",
    "Ryan",
    "Endrico",
    "Rick",
    "Richard",
    "Franky",
    "Kerwin",
    "Yendricco",
    "Daniel",
    "Ray"
  ];

  // ---------- Helpers ----------
  function parseScore(val) {
    if (val === null || val === undefined) return null;
    const s = String(val).trim();
    if (s === "") return null;
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  function shuffle(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // Returns a string signature so we can avoid repeating the exact same matchup too much
  function matchupSig(teamA, teamB) {
    const A = teamA.slice().sort().join("|");
    const B = teamB.slice().sort().join("|");
    return [A, B].sort().join(" VS ");
  }

  // Generate "reasonable" random schedule:
  // - each game uses 6 players (3v3)
  // - tries to rotate players evenly
  // - avoids repeating the exact same matchup signature
function generateScheduleGuaranteedFair(roster, gamesCount) {
  if (roster.length < 6) throw new Error("Need at least 6 players for 3v3.");

  const n = roster.length;
  const totalSlots = gamesCount * 6;

  // Base target + remainder distribution
    const target = {};

  if (totalSlots % n === 0) {
    const exact = totalSlots / n;
    roster.forEach(p => target[p] = exact);
  } else {
    const base = Math.floor(totalSlots / n);
    const extra = totalSlots % n;

    const shuffledRoster = shuffle(roster);
    shuffledRoster.forEach((p, i) => {
      target[p] = base + (i < extra ? 1 : 0);
    });
  }

  // Remaining quota
  const remaining = { ...target };

  // Track teammate pair counts (to reduce repeats)
  const pairCount = new Map(); // key "A|B" sorted
  const pairKey = (a, b) => [a, b].sort().join("|");
  const addPairs = (team) => {
    for (let i = 0; i < team.length; i++) {
      for (let j = i + 1; j < team.length; j++) {
        const k = pairKey(team[i], team[j]);
        pairCount.set(k, (pairCount.get(k) || 0) + 1);
      }
    }
  };
  const teamPenalty = (team) => {
    // sum of existing teammate pair counts (lower is better)
    let s = 0;
    for (let i = 0; i < team.length; i++) {
      for (let j = i + 1; j < team.length; j++) {
        s += (pairCount.get(pairKey(team[i], team[j])) || 0);
      }
    }
    return s;
  };

  const games = [];

  // Try to build each game with backtracking-lite retries
  for (let id = 1; id <= gamesCount; id++) {
    let success = false;

    for (let attempt = 0; attempt < 500; attempt++) {
      // Eligible players still needing games
      const eligible = roster.filter(p => remaining[p] > 0);

      // Must have at least 6 eligible to fill the game
      if (eligible.length < 6) break;

      // Build a candidate pool biased toward higher remaining quota
      // (so we don't strand someone at the end)
      const weighted = [];
      eligible.forEach(p => {
        for (let k = 0; k < remaining[p]; k++) weighted.push(p);
      });

      // pick 6 unique
      const picked = [];
      const used = new Set();
      while (picked.length < 6) {
        const p = weighted[Math.floor(Math.random() * weighted.length)];
        if (!used.has(p)) {
          used.add(p);
          picked.push(p);
        }
      }

      // split into teams; try a few splits and take the lowest penalty
      const splits = [];
      for (let s = 0; s < 25; s++) {
        const m = shuffle(picked);
        const a = m.slice(0, 3);
        const b = m.slice(3, 6);
        const pen = teamPenalty(a) + teamPenalty(b);
        splits.push({ a, b, pen });
      }
      splits.sort((x, y) => x.pen - y.pen);
      const best = splits[0];

      // Validate: after using these 6, no one should go negative (they won't)
      // But we ALSO need to ensure feasibility for remaining games:
      // simple feasibility check: total remaining slots after this game must fit eligible counts
      const tempRemaining = { ...remaining };
      [...best.a, ...best.b].forEach(p => tempRemaining[p]--);

      const remainingSlots = Object.values(tempRemaining).reduce((acc, v) => acc + v, 0);
      const gamesLeft = gamesCount - id;
      if (remainingSlots !== gamesLeft * 6) continue; // must match exactly

      // Good: commit
      remaining[best.a[0]]--; remaining[best.a[1]]--; remaining[best.a[2]]--;
      remaining[best.b[0]]--; remaining[best.b[1]]--; remaining[best.b[2]]--;

      addPairs(best.a);
      addPairs(best.b);

      games.push({ id, a: best.a, b: best.b });
      success = true;
      break;
    }

    if (!success) {
      // If we fail (rare), restart entirely with a new random assignment of who gets extra
      return generateScheduleGuaranteedFair(roster, gamesCount);
    }
  }

  return games;

  // ---- helper ----
  function shuffle(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }
}

  function getRosterFromSetup() {
    const count = Number(document.getElementById("playerCount").value);
    const inputs = Array.from(document.querySelectorAll(".nameInput"));
    const roster = inputs
      .slice(0, count)
      .map(i => i.value.trim())
      .filter(Boolean);

    // If user deletes a name, fill with placeholder
    while (roster.length < count) roster.push(`Player ${roster.length + 1}`);

    // Enforce unique names (case-insensitive) so fairness logic works correctly
    const lower = roster.map(n => n.toLowerCase());
    const dupLower = lower.find((n, i) => lower.indexOf(n) !== i);
    if (dupLower) {
      const firstIdx = lower.indexOf(dupLower);
      alert(`Duplicate name detected: "${roster[firstIdx]}". Please make all names unique.`);
      throw new Error("Duplicate player names");
    }

    return roster;
  }

  function saveLeague(roster, games) {
    localStorage.setItem(STORE.roster, JSON.stringify(roster));
    localStorage.setItem(STORE.games, JSON.stringify(games));
    localStorage.setItem(STORE.meta, JSON.stringify({ createdAt: Date.now() }));
  }

  function loadLeague() {
    const rosterRaw = localStorage.getItem(STORE.roster);
    const gamesRaw = localStorage.getItem(STORE.games);
    if (!rosterRaw || !gamesRaw) return null;
    try {
      return {
        roster: JSON.parse(rosterRaw),
        games: JSON.parse(gamesRaw),
      };
    } catch {
      return null;
    }
  }

  function clearScoresOnly(games) {
    games.forEach(g => {
      localStorage.removeItem(scoreKey(g.id, "a"));
      localStorage.removeItem(scoreKey(g.id, "b"));
    });
  }

  function clearEverything() {
    const league = loadLeague();
    if (league?.games) clearScoresOnly(league.games);
    localStorage.removeItem(STORE.roster);
    localStorage.removeItem(STORE.games);
    localStorage.removeItem(STORE.meta);
  }

  // ---------- UI routing ----------
  function showSetup() {
    document.getElementById("setupScreen").classList.remove("hidden");
    document.getElementById("leagueScreen").classList.add("hidden");
  }

  function showLeague() {
    document.getElementById("setupScreen").classList.add("hidden");
    document.getElementById("leagueScreen").classList.remove("hidden");
  }

  // ---------- Setup Screen ----------
  function renderNameInputs() {
  const grid = document.getElementById("namesGrid");
  grid.innerHTML = "";

  const count = Number(document.getElementById("playerCount").value);

  for (let i = 0; i < 12; i++) {
    const wrap = document.createElement("div");

    const label = document.createElement("div");
    label.className = "pill";
    label.style.margin = "0 0 8px";
    label.textContent = `Player ${i + 1}`;

    const input = document.createElement("input");
    input.type = "text";
    input.className = "nameInput";
    input.placeholder = "Enter name...";
    input.value = ""; // <-- no autofill

    if (i >= count) {
      input.disabled = true;
      input.style.opacity = "0.4";
    }

    wrap.appendChild(label);
    wrap.appendChild(input);
    grid.appendChild(wrap);
  }
}

  // ---------- League Screen ----------
  let gamesData = [];
  let players = [];

  function renderGames() {
    const root = document.getElementById("games");
    root.innerHTML = "";

    gamesData.forEach(g => {
      const card = document.createElement("div");
      card.className = "game";

      const top = document.createElement("div");
      top.className = "game-top";

      const title = document.createElement("div");
      title.className = "gtitle";
      title.textContent = `Game ${g.id}`;

      const inputs = document.createElement("div");
      inputs.className = "inputs";

      const aInput = document.createElement("input");
      aInput.type = "number";
      aInput.min = "0";
      aInput.placeholder = "Team A";
      aInput.value = localStorage.getItem(scoreKey(g.id, "a")) ?? "";

      const bInput = document.createElement("input");
      bInput.type = "number";
      bInput.min = "0";
      bInput.placeholder = "Team B";
      bInput.value = localStorage.getItem(scoreKey(g.id, "b")) ?? "";

      aInput.addEventListener("input", () => {
        localStorage.setItem(scoreKey(g.id, "a"), aInput.value);
        updateStandings();
        renderGames(); // refresh winner glow
      });

      bInput.addEventListener("input", () => {
        localStorage.setItem(scoreKey(g.id, "b"), bInput.value);
        updateStandings();
        renderGames(); // refresh winner glow
      });

      inputs.appendChild(aInput);
      inputs.appendChild(bInput);

      top.appendChild(title);
      top.appendChild(inputs);

      const teams = document.createElement("div");
      teams.className = "teams";

      const teamA = document.createElement("div");
      teamA.className = "team";
      teamA.textContent = g.a.join(" â€“ ");

      const vs = document.createElement("div");
      vs.className = "vs";
      vs.textContent = "vs";

      const teamB = document.createElement("div");
      teamB.className = "team";
      teamB.textContent = g.b.join(" â€“ ");

      // Winner highlight
      const aScore = parseScore(localStorage.getItem(scoreKey(g.id, "a")));
      const bScore = parseScore(localStorage.getItem(scoreKey(g.id, "b")));
      if (aScore !== null && bScore !== null) {
        if (aScore > bScore) teamA.classList.add("winner");
        else if (bScore > aScore) teamB.classList.add("winner");
      }

      teams.appendChild(teamA);
      teams.appendChild(vs);
      teams.appendChild(teamB);

      card.appendChild(top);
      card.appendChild(teams);
      root.appendChild(card);
    });
  }

  function emptyStats() {
    const map = {};
    players.forEach(p => {
      map[p] = { name: p, W:0, D:0, L:0, PF:0, PA:0 };
    });
    return map;
  }

  function updateStandings() {
    const stats = emptyStats();

    gamesData.forEach(g => {
      const aScore = parseScore(localStorage.getItem(scoreKey(g.id, "a")));
      const bScore = parseScore(localStorage.getItem(scoreKey(g.id, "b")));
      if (aScore === null || bScore === null) return;

      // track PF/PA only for diff tie-break
      g.a.forEach(p => { stats[p].PF += aScore; stats[p].PA += bScore; });
      g.b.forEach(p => { stats[p].PF += bScore; stats[p].PA += aScore; });

      if (aScore > bScore) {
        g.a.forEach(p => stats[p].W += 1);
        g.b.forEach(p => stats[p].L += 1);
      } else if (bScore > aScore) {
        g.b.forEach(p => stats[p].W += 1);
        g.a.forEach(p => stats[p].L += 1);
      } else {
        g.a.forEach(p => stats[p].D += 1);
        g.b.forEach(p => stats[p].D += 1);
      }
    });

    const rows = Object.values(stats).map(s => {
      const Diff = s.PF - s.PA;
      const Pts = s.W - s.L; // Win +1, Draw 0, Loss -1
      return { ...s, Diff, Pts };
    });

    // Sort: Points desc, Diff desc, Name asc
    rows.sort((x, y) => {
      if (y.Pts !== x.Pts) return y.Pts - x.Pts;
      if (y.Diff !== x.Diff) return y.Diff - x.Diff;
      return x.name.localeCompare(y.name);
    });

    const tbody = document.getElementById("standingsBody");
    tbody.innerHTML = "";

    rows.forEach((r, idx) => {
      let medal = "";
      if (idx === 0) medal = "ðŸ¥‡";
      if (idx === 1) medal = "ðŸ¥ˆ";
      if (idx === 2) medal = "ðŸ¥‰";

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="rank">${idx + 1}</td>
        <td class="name"><span class="medal">${medal}</span>${r.name}</td>
        <td>${r.W}</td>
        <td>${r.D}</td>
        <td>${r.L}</td>
        <td>${r.Pts}</td>
        <td>${r.Diff}</td>
      `;
      tbody.appendChild(tr);
    });
  }

  function bootLeagueFromStorage() {
    const league = loadLeague();
    if (!league) return false;

    gamesData = league.games;
    players = league.roster.slice().sort();
    return true;
  }

  // ---------- Events ----------
  document.getElementById("playerCount").addEventListener("change", renderNameInputs);

  document.getElementById("btnGenerate").addEventListener("click", () => {
    const roster = getRosterFromSetup();
    const gamesCount = Number(document.getElementById("gamesCount").value);

    const games = generateScheduleGuaranteedFair(roster, gamesCount);
    saveLeague(roster, games);

    // clear old scores for old game ids
    clearScoresOnly(games);

    // go league
    bootLeagueFromStorage();
    showLeague();
    renderGames();
    updateStandings();
  });

  document.getElementById("btnBack").addEventListener("click", () => {
    showSetup();
  });

  document.getElementById("btnReset").addEventListener("click", () => {
    clearScoresOnly(gamesData);
    renderGames();
    updateStandings();
  });

  document.getElementById("btnRegenerate").addEventListener("click", () => {
    // regenerate using current setup inputs (so you can edit names first)
    showSetup();
    // keep name inputs visible; user clicks Generate again
  });

  document.getElementById("btnClearLeague").addEventListener("click", () => {
    const ok = confirm("Clear league (matches + scores) and return to setup?");
    if (!ok) return;
    clearEverything();
    showSetup();
    renderNameInputs();
  });

  // ---------- Init ----------
  renderNameInputs();

  // If league exists, open league screen directly
  if (bootLeagueFromStorage()) {
    showLeague();
    renderGames();
    updateStandings();
  } else {
    showSetup();
  }
</script>
</body>
</html>
